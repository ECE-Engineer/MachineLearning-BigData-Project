<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HashAlgorithm.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">01</a> &gt; <a href="index.source.html" class="el_package">default</a> &gt; <span class="el_source">HashAlgorithm.java</span></div><h1>HashAlgorithm.java</h1><pre class="source lang-java linenums">/**
 * @author Kyle Zeller
 * This class provides a way to store and access all of the exoplanet objects in an efficient manner.
 */

import java.util.ArrayList;

public class HashAlgorithm&lt;V&gt; {

    /**
     * The constructor calls HT() to initialize the size of the HashTable.
     */
<span class="fc" id="L13">    HashAlgorithm() {</span>
<span class="fc" id="L14">        this.HT();</span>
<span class="fc" id="L15">    }</span>

    static class Entry&lt;V&gt; {
        final String key;
        V value;
        Entry&lt;V&gt; next;
        int hash;

        /**
         *Creates the key / value pairs
         * @param k is the unique identification value that the object has
         * @param v is the Exoplanet object
         * @param n is the Entry tuple
         * @param h is the unique hashing value to the unique key that was given
         */
<span class="fc" id="L30">        Entry(String k, V v, Entry&lt;V&gt; n, int h) {</span>
<span class="fc" id="L31">            key = k;</span>
<span class="fc" id="L32">            value = v;</span>
<span class="fc" id="L33">            next = n;</span>
<span class="fc" id="L34">            hash = h;</span>
<span class="fc" id="L35">        }</span>
    }

    /*tab.length should always be a power of 2*/
    Entry&lt;V&gt;[] tab;

    /**
     * Initializes the size of the HashTable.
     */
    public void HT() {
<span class="fc" id="L45">        tab = new Entry[16];    // selected to be a good starting size</span>
<span class="fc" id="L46">    }</span>

    /**
     *
     * Looks for a key already present in the hash table
     */
    public boolean containsKey(String key){
<span class="nc" id="L53">        int h = hashCode(key);</span>
<span class="nc" id="L54">        Entry&lt;V&gt;[] t = tab;</span>
<span class="nc" id="L55">        int i = h &amp; (tab.length-1);</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">        for (Entry&lt;V&gt; e = t[i]; e != null; e=e.next){</span>
            //see if there is a match
<span class="nc bnc" id="L58" title="All 4 branches missed.">            if (e.hash == h &amp;&amp; key.equals(e.key))</span>
<span class="nc" id="L59">                return true;</span>
        }
<span class="nc" id="L61">        return false;</span>
    }

    /**
     * Retrieves an Exoplanet from the given key in the hash table
     * @param s is a key that will be used to access it's respective exoplanet object
     * @return returns an exoplanet object corresponding to the key given
     */
    public V getValue(String s) {
        //update --- handle collisions
<span class="fc" id="L71">        int h = hashCode(s);</span>
<span class="fc" id="L72">        Entry&lt;V&gt;[] t = tab;</span>
<span class="fc" id="L73">        int i = h &amp; (tab.length-1);</span>

<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        for (Entry&lt;V&gt; e = t[i]; e != null; e = e.next){</span>
            //get the value from the end of the list
<span class="pc bpc" id="L77" title="1 of 4 branches missed.">            if (e.hash == h &amp;&amp; s.equals(e.key)){</span>
<span class="fc" id="L78">                return e.value;</span>
            }
        }

<span class="nc" id="L82">        return null;</span>
    }

    /**
     * Retrieves all the keys in the hash table
     * @return returns the keys in the hash table
     */
    public ArrayList&lt;String&gt; keySet(){
<span class="nc" id="L90">        ArrayList&lt;String&gt; temp = new ArrayList&lt;String&gt;();</span>

        //look for the values on the tuple array
<span class="nc bnc" id="L93" title="All 2 branches missed.">        for (int k = 0; k &lt; tab.length; ++k){</span>
            //check to see if there is ALREADY a value at this key
<span class="nc bnc" id="L95" title="All 2 branches missed.">            if (tab[k] != null){</span>
                //add all the values on the linked list (including the first one)
<span class="nc bnc" id="L97" title="All 2 branches missed.">                for (Entry&lt;V&gt; e = tab[k]; e != null; e = e.next){</span>
<span class="nc" id="L98">                    temp.add(e.key);</span>
                }
            }
        }

<span class="nc" id="L103">        return temp;</span>
    }

    /**
     * Clears everything in the hash table
     */
    public void clear() {   // remove all tuples
        //look for the values on the tuple array
<span class="nc bnc" id="L111" title="All 2 branches missed.">        for (int k = 0; k &lt; tab.length; ++k){</span>
            //check to see if there is ALREADY a value at this key
<span class="nc bnc" id="L113" title="All 2 branches missed.">            if (tab[k] != null){</span>
                //remove all the values on the linked list (including the first one)
<span class="nc" id="L115">                tab[k] = null;</span>
            }
        }
<span class="nc" id="L118">    }</span>

    /**
     * Determines how many exoplanet objects are currently being stored in the hashtable
     * @return returns the amount of exoplanet objects currently stored in the hashtable
     */
    public int size() {
<span class="fc" id="L125">        int count = 0;</span>

        //look for the values on the tuple array
<span class="fc bfc" id="L128" title="All 2 branches covered.">        for (int k = 0; k &lt; tab.length; ++k){</span>
            //check to see if there is ALREADY a value at this key
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if (tab[k] != null){</span>
                //count all the values on the linked list (including the first one)
<span class="fc bfc" id="L132" title="All 2 branches covered.">                for (Entry&lt;V&gt; e = tab[k]; e != null; e = e.next){</span>
<span class="fc" id="L133">                    count++;</span>
                }
            }
        }

<span class="fc" id="L138">        return count;</span>
    }

    /**
     * Checks to see if there is nothing in the hashtable
     * @return returns true if the hashtable is empty
     */
    public boolean isEmpty() {
<span class="nc bnc" id="L146" title="All 2 branches missed.">        return this.size() == 0;</span>
    }

<span class="fc" id="L149">    int count = 0;</span>

    /**
     * Adds an Exoplanet to the hash table
     * @param key is the unique identification value that the object has
     * @param value is the exoplanet that is going to be stored
     */
    public void put(String key, V value){
        //update
<span class="fc" id="L158">        int h = hashCode(key);</span>
<span class="fc" id="L159">        Entry&lt;V&gt;[] t = tab;</span>
<span class="fc" id="L160">        int i = h &amp; (tab.length-1);</span>

<span class="fc bfc" id="L162" title="All 2 branches covered.">        for (Entry&lt;V&gt; e = t[i]; e != null; e = e.next){</span>
            //check to see if there is ALREADY a value at this key
<span class="pc bpc" id="L164" title="3 of 4 branches missed.">            if (e.hash == h &amp;&amp; key.equals(e.key)){</span>
                //lengthen the list
<span class="nc" id="L166">                e.value = value;</span>
<span class="nc" id="L167">                return;</span>
            }
        }


        //handle collisions
        //add --- make a new entry for a key, value tuple
<span class="fc" id="L174">        Entry&lt;V&gt; p = new Entry(key, value, t[i], h);</span>
<span class="fc" id="L175">        t[i] = p;</span>

        //resize --- the array
<span class="fc" id="L178">        int n = t.length;</span>
<span class="fc" id="L179">        int c = ++count;</span>
        //check if the size is smaller than the threshold
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if ((c/(float)t.length) &lt; 0.75)</span>
<span class="fc" id="L182">            return;</span>

        //double the size of the array
<span class="nc" id="L185">        int newN = n &lt;&lt; 1;</span>
<span class="nc" id="L186">        Entry&lt;V&gt;[] newTab = new Entry[newN];</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">        for (int k = 0; k &lt; n; ++k){</span>
            Entry&lt;V&gt; e;
<span class="nc bnc" id="L190" title="All 2 branches missed.">            while ((e = t[k]) != null){ // add to the linked list</span>
<span class="nc" id="L191">                t[k] = e.next;</span>
<span class="nc" id="L192">                int j = e.hash &amp; (newN - 1);</span>
<span class="nc" id="L193">                e.next = newTab[j];</span>
<span class="nc" id="L194">                newTab[j] = e;</span>
<span class="nc" id="L195">            }</span>
            // add to the tuple array
<span class="nc" id="L197">            tab = newTab;</span>
        }
<span class="nc" id="L199">    }</span>

    /**
     * Removes an Exoplanet at the specified key
     * @param key is the unique identification value that the object has
     */
    public void remove(String key){
        //update --- handle collisions
<span class="nc" id="L207">        int h = hashCode(key);</span>
<span class="nc" id="L208">        Entry&lt;V&gt;[] t = tab;</span>
<span class="nc" id="L209">        int i = h &amp; (tab.length-1);</span>
<span class="nc" id="L210">        Entry&lt;V&gt; pred = null;</span>
<span class="nc" id="L211">        Entry&lt;V&gt; p = t[i];</span>

<span class="nc bnc" id="L213" title="All 2 branches missed.">        while (p != null) {</span>
<span class="nc bnc" id="L214" title="All 4 branches missed.">            if (p.hash == h &amp;&amp; key.equals(p.key)) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                if (pred == null)</span>
<span class="nc" id="L216">                    t[i] = p.next;</span>
                else
<span class="nc" id="L218">                    pred.next = p.next;</span>
<span class="nc" id="L219">                --count;</span>
<span class="nc" id="L220">                return;</span>
            }
<span class="nc" id="L222">            pred = p;</span>
<span class="nc" id="L223">            p = p.next;</span>
        }

        //remove --- remove an entry for a key, value tuple
<span class="nc" id="L227">        t[i] = null;</span>

        //resize --- the array
<span class="nc" id="L230">        int n = t.length;</span>
<span class="nc" id="L231">        int c = ++count;</span>
        //check if the size is greater than the threshold
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if ((c/(float)t.length) &gt; 0.25)</span>
<span class="nc" id="L234">            return;</span>

        //halve the size of the array
<span class="nc" id="L237">        int newN = n &gt;&gt;&gt; 1;</span>
<span class="nc" id="L238">        Entry&lt;V&gt;[] newTab = new Entry[newN];</span>

<span class="nc bnc" id="L240" title="All 2 branches missed.">        for (int k = 0; k &lt; n; ++k){</span>
            Entry&lt;V&gt; e;
<span class="nc bnc" id="L242" title="All 2 branches missed.">            while ((e = t[k]) != null){ // add to the linked list</span>
<span class="nc" id="L243">                t[k] = e.next;</span>
<span class="nc" id="L244">                int j = e.hash &amp; (newN - 1);</span>
<span class="nc" id="L245">                e.next = newTab[j];</span>
<span class="nc" id="L246">                newTab[j] = e;</span>
<span class="nc" id="L247">            }</span>
            // add to the tuple array
<span class="nc" id="L249">            tab = newTab;</span>
        }
<span class="nc" id="L251">    }</span>

    /**
     * Creates a unique hash value for the given
     * @param s is the unique identification value that the object has
     * @return returns the unique hashing value to the unique key that was given
     */
    public int hashCode(String s){
<span class="fc" id="L259">        char[] info = s.toCharArray();</span>

        int temp, i;
<span class="fc bfc" id="L262" title="All 2 branches covered.">        for (temp = i = 0; i &lt; s.length(); ++i) {</span>
<span class="fc" id="L263">            temp += info[i];</span>
<span class="fc" id="L264">            temp += (temp &lt;&lt; 10);</span>
<span class="fc" id="L265">            temp ^= (temp &gt;&gt;&gt; 6);</span>
        }
<span class="fc" id="L267">        temp += (temp &lt;&lt; 3);</span>
<span class="fc" id="L268">        temp ^= (temp &gt;&gt;&gt; 11);</span>
<span class="fc" id="L269">        temp += (temp &lt;&lt; 15);</span>
<span class="fc" id="L270">        return temp;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>